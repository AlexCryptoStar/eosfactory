# Tutorial Getting Started With Contracts

We rephrase an [article](#https://github.com/EOSIO/eos/wiki/Tutorial-Getting-Started-With-Contracts) from EOSIO wiki.

## Getting Started with Contracts

The purpose of this tutorial is to demonstrate primary experiments with smart contracts. This tutorial assumes that you have installed both [*EOSIO*](#https://github.com/EOSIO/eos) and [*Tokenika Logos*](#https://github.com/tokenika/logos). If so, you have installed *python3*, as well.

To begin with, open a bash terminal in the `teos_python` directory of the *Logos* repository. Start `python3`:
```
import teos
teos.set_verbose(True)
```

## Starting a Private Blockchain

Launch an object of `teos.DaemonClear()` that starts the local EOSIO node, beginning a new blockchain:
```
teos.DaemonClear()
#       nodeos exe file: /mnt/e/Workspaces/EOS/eos/build/programs/nodeos/nodeos
#    genesis state file: /mnt/e/Workspaces/EOS/eos/build/programs/daemon/data-dir/genesis.json
#        server address: 127.0.0.1:8888
#      config directory: /mnt/e/Workspaces/EOS/eos/build/programs/daemon/data-dir
#      wallet directory: /mnt/e/Workspaces/EOS/eos/build/programs/daemon/data-dir/wallet
#     head block number: 2
#       head block time: 2018-04-10T17:20:54
```
Now, a newly started terminal has the local node running.

## Creating a Wallet

A wallet is a repository of private keys necessary to authorize actions on the blockchain. These keys are stored on disk encrypted using a password generated by the EOSIO node. 

Launch an object `teos.Wallet` that implements a local wallet:
```
wallet = teos.Wallet()
#              password: PW5KLhcjMHeLxiyyrFU8EWncXUHHLNWgw7uxmvKMwMC19jMHR6zWk
#  You need to save this password to be able to lock/unlock the wallet!
```
The wallet name argument is not set here: it defaults to 'default'.

When doing with a real value, this password should be stored in a secure password manager, however, for the purpose of development environment, the password is kept in the wallet object. Therefore, the following instructions make sense:
```
wallet.lock()
wallet.list()
#                wallet: default
wallet.unlock()
>>> wallet.list()          # The starlet marks unlocked:
#                wallet: default *
```

## The Eosio Account and the Bios Contract

You have to owe an valid EOSIO account to be authorized to interact with EOSIO. For tests, you can use the ‘eosio’ account:

```
account_eosio = teos.EosioAccount()
account_eosio.key_private
'5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3'
```
You have to have the private key to your property in your wallet. Perhaps, it is there already:
```
wallet.keys()
#  {
#      "wallet keys": [
#          [
#              "EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV",
#              "5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3"
#          ]
#      ]
#  }
```
Indeed, your wallet contains the key to `account_eosio`. I it was not there, you could import it. Now, the following attempt is rejected:
```
wallet.import_key(account_eosio)
ERROR! status code is 500  eosd response is Content-Length: 234  Content-type:
application/json  Server: WebSocket++/0.7.0    {"code":500,"message":"Internal
Service Error","error":{"code":10,"name":"assert_exception","what":"Assert
Exception","details":[{"message":"!\"Key already in wallet\":
","file":"wallet.cpp","line_number":150,"method":"import_key"}]}}
```

Now that you have a wallet with the key for the eosio account loaded, you can set a *default system contract*. For the purposes of development, the default `eosio.bios` contract can be used. This contract enables you to have direct control over the resource allocation of other accounts and to access other privileged API calls. In a public blockchain, this contract will manage the staking and unstaking of tokens to reserve bandwidth for CPU and network activity, and memory for contracts.

The eosio.bios contract can be found in the contracts/eosio.bios folder of your EOSIO source code. The Tokenika teos python is configured to find the proper path.
```
contract_eosio_bios = teos.SetContract(
  account_eosio, "eosio.bios", permission=account_eosio)
#        transaction id: fd45de61bd9f05a570df44faf5fd4db182f6a4f4d4da3b0302735f23645f63d2
``` 
The transaction is authorized and signed by `account_eosio`. 

As the set contract command call has produced the transaction id, the default contract is operational. The result of this transaction setting is that it is generated a transaction with two actions, eosio::setcode and eosio::setabi.

The contract is set to the node in two parts: `code` and `abi` The code defines how the contract runs and the abi describes how to convert between binary and json representations of the arguments. While an abi is technically optional, all of the EOSIO tooling depends upon it for ease of use.

## Creating Accounts

Now that you have set the basic system contract, you can start to create our own accounts. You will create two accounts, user and tester, and you will need to associate a key with each account. In this example, the same key will be used for both accounts.

To do this you first generate a key for the accounts and import it to the wallet.
```
key_accounts = teos.CreateKey("key_accounts")
#              key name: key_accounts
#           private key: 5JG3gEsowhnQXEYD1z4Vmh2iJMnNrb8oSg9TBVbLFjV7dSuDTrW
#            public key: EOS4vA5JV7zKTJCa83LHrvzbHv4z6G5g6GLXMgSB3JZQu5rDpRueS

wallet.import_key(key_accounts)
```
### Create Two User Accounts

Next you will create two accounts, user and tester, using the key you created and imported above.
```
account_user = teos.Account(account_eosio, "user", key_accounts, key_accounts)
#        transaction id: f94c26662da514fac7027270531e023a6fc8cd4dcd739dc67e...

account_tester = teos.Account(
   account_eosio, "tester", key_accounts, key_accounts)
   #        transaction id: 6eb3e7a64ac2265de855f9c8b0c5677848e8451b4d6dda8...
```
NOTE: The create account subcommand requires two keys, one for the OwnerKey (which in a production environment should be kept highly secure) and one for the ActiveKey. In this tutorial example, the same key is used for both.

You can query all accounts that are controlled `key_accounts` key:
```
teos.GetAccounts(key_accounts)
#  {
#      "account_names": [
#          "tester",
#          "user"
#      ]
#  }
```

## Eosio.token, Exchange, and Eosio.msig Contracts

At this stage the blockchain doesn't do much, so let's deploy the eosio.token contract. This contract enables the creation of many different tokens all running on the same contract but potentially managed by different users.

Before we can deploy the token contract we must create an account to deploy it to.
```
account_eosio_token = teos.Account(
  account_eosio, "eosio.token", key_accounts, key_accounts)
#        transaction id: 64dcf4a8f522daea9699b48bcacee797273f4ca42ee6cb9de0...
```
Then we can deploy the contract which can be found in ${EOSIO_SOURCE}/build/contracts/eosio.token:
```
contract_eosio_token = teos.Contract(
  account_eosio_token, "eosio.token", permission=account_eosio_token)
#        transaction id: 286fecdb671fd8e0128acb4f28a1a10cc2a8e195047748ef54...
```

## Create the EOS Token

You can view the interface to eosio.token as defined by contracts/eosio.token/eosio.token.hpp:
```
   void create( account_name issuer,
                asset        maximum_supply,
                uint8_t      can_freeze,
                uint8_t      can_recall,
                uint8_t      can_whitelist );


   void issue( account_name to, asset quantity, string memo );

   void transfer( account_name from,
                  account_name to,
                  asset        quantity,
                  string       memo );
```
To create a new token we must call the create(...) action with the proper arguments. This command will use the symbol of the maximum supply to uniquely identify this token from other tokens. The issuer will be the one with authority to call issue and or perform other actions such as freezing, recalling, and whitelisting of owners.
```
contract_eosio_token.action(
  "create",
  '{"issuer":"eosio", "maximum_supply":"1000000000.0000 EOS", \
    "can_freeze":0, "can_recall":0, "can_whitelist":0}')
#        transaction id: 42df2cca11971b5af6478156d33e2cd8f5869de6a80090efc6...
```
You can read the above: 

Let contract `contract_eosio_token` use its `create` method with arguments as defined with the second argument. Let this action be explicitly (default setting) signed by its creator, that is `account_eosio_token`.

This command created a new token EOS with a pecision of 4 decimials and a maximum supply of 1000000000.0000 EOS.

### Issue Tokens to Account "User"

Now that we have created the token, the issuer can issue new tokens to the account user we created earlier.
```
contract_eosio_token.action(
  "issue",
  '{"to":"user","quantity":"100.0000 EOS","memo":"memo"}',
  permission=account_eosio)
#        transaction id: 015a870a42ffd3d9e86776cc36c06b28d9d4246ad585d8566f...
```
However, our *TEOS python* is not ready to display that yet, 
this time it has happened several different actions: one issue and three transfers. While the only action we signed was issue, the issue action performed an "inline transfer" and the "inline transfer" notified the sender and receiver accounts. The output indicates all of the action handlers that were called, the order they were called in, and whether or not any output was generated by the action.

The equivalent response of *EOSIO cleos* is as it follows:
```
$ cleos push action eosio.token issue '[ "user", "100.0000 EOS", "memo" ]' -p eosio
executed transaction: 822a607a9196112831ecc2dc14ffb1722634f1749f3ac18b73ffacd41160b019  268 bytes  1000 cycles
#   eosio.token <= eosio.token::issue           {"to":"user","quantity":"100.0000 EOS","memo":"memo"}
>> issue
#   eosio.token <= eosio.token::transfer        {"from":"eosio","to":"user","quantity":"100.0000 EOS","memo":"memo"}
>> transfer
#         eosio <= eosio.token::transfer        {"from":"eosio","to":"user","quantity":"100.0000 EOS","memo":"memo"}
#          user <= eosio.token::transfer        {"from":"eosio","to":"user","quantity":"100.0000 EOS","memo":"memo"}
```
```
contract_eosio_token.action(
  "issue",
  '{"to":"user","quantity":"100.0000 EOS","memo":"memo"}',
  permission=account_eosio,
  dont_broadcast=1)
```

## Summary

```
daemon = teos.DaemonClear()
wallet = teos.Wallet()
wallet.lock()
wallet.list()
wallet.unlock()
wallet.list()
account_eosio = teos.EosioAccount()
account_eosio.key_private
wallet.keys()
wallet.import_key(account_eosio)
contract_eosio_bios = teos.SetContract(
  account_eosio, "eosio.bios", permission=account_eosio)
key_accounts = teos.CreateKey("key_accounts")

# break here

wallet.import_key(key_accounts)
account_user = teos.Account(
   account_eosio, "user", key_accounts, key_accounts)
account_tester = teos.Account(
   account_eosio, "tester", key_accounts, key_accounts) 
teos.GetAccounts(key_accounts)

account_eosio_token = teos.Account(
  account_eosio, "eosio.token", key_accounts, key_accounts)
contract_eosio_token = teos.Contract(
  account_eosio_token, "eosio.token", permission=account_eosio_token)

contract_eosio_token.action(
  "create",
  '{"issuer":"eosio", "maximum_supply":"1000000000.0000 EOS", \
    "can_freeze":0, "can_recall":0, "can_whitelist":0}') 

contract_eosio_token.action(
  "issue",
  '{"to":"user","quantity":"100.0000 EOS","memo":"memo"}',
  permission=account_eosio)



```
