   createAccount->set_callback([&] {
      public_key_type owner_key, active_key;
      try {
         owner_key = public_key_type(owner_key_str);
         active_key = public_key_type(active_key_str);
      } EOS_CAPTURE_AND_RETHROW(public_key_type_exception, "Invalid Public Key")
      send_actions({create_newaccount(creator, account_name, owner_key, active_key)});
   });

chain::action create_newaccount(
  const name& creator, const name& newaccount, 
  public_key_type owner, public_key_type active) 
{
   return action {
      tx_permission.empty() 
        ? vector<chain::permission_level>{{creator,config::active_name}} 
        : get_account_permissions(tx_permission),
      contracts::newaccount{
         .creator      = creator,
         .name         = newaccount,
         .owner        = eosio::chain::authority{1, {{owner, 1}}, {}},
         .active       = eosio::chain::authority{1, {{active, 1}}, {}},
         .recovery     = eosio::chain::authority{1, {}, {{{creator, config::active_name}, 1}}}
      }
   };
}

void send_actions(
  std::vector<chain::action>&& actions, 
  packed_transaction::compression_type compression = packed_transaction::none ) 
{
   std::cout << fc::json::to_pretty_string(
    push_actions(
      std::forward<decltype(actions)>(actions), 
      compression)
    ) << std::endl;
}

fc::variant push_actions(
  std::vector<chain::action>&& actions, 
  packed_transaction::compression_type compression = packed_transaction::none 
  ) 
  {
   signed_transaction trx;
   trx.actions = std::forward<decltype(actions)>(actions);

   return push_transaction(trx, compression);
}

fc::variant push_transaction( 
  signed_transaction& trx, 
  packed_transaction::compression_type compression = packed_transaction::none ) 
  
  {
   auto info = get_info();
   trx.expiration = info.head_block_time + tx_expiration;
   trx.set_reference_block(info.head_block_id);

   if (tx_force_unique) {
      trx.context_free_actions.emplace_back( generate_nonce() );
   }

   if (!tx_skip_sign) {
      sign_transaction(trx);
   }

   if (!tx_dont_broadcast) {
      return call(push_txn_func, packed_transaction(trx, compression));
   } else {
      return fc::variant(trx);
   }
}

CallChain /*void*/ sign_transaction(signed_transaction& trx) {
   // TODO better error checking
   /*
   const auto& public_keys = call(
      wallet_host, wallet_port, wallet_public_keys);
   */
   CallChain callPublicKeys(wallet_public_keys);
      if(callPublicKeys.isError_) {
        return callPublicKeys;
      }
   const auto& public_keys = callPublicKeys.fcVariant_;
   
   auto get_arg = fc::mutable_variant_object
         ("transaction", (transaction)trx)
         ("available_keys", public_keys);

   /*
   const auto& required_keys = call(host, port, get_required_keys, get_arg);
   */
   CallChain callRequiredKeys(get_required_keys, get_arg);
   if(callRequiredKeys.isError_){
   return callRequiredKeys;
   }
   const auto& required_keys = callRequiredKeys.fcVariant_;

   // TODO determine chain id
   fc::variants sign_args = {fc::variant(trx), required_keys["required_keys"], fc::variant(chain_id_type{})};
   /*
   const auto& signed_trx = call(wallet_host, wallet_port, wallet_sign_trx, sign_args);
   */
   return CallChain(wallet_sign_trx, sign_args)/*.fcVariant_.as<signed_transaction>()*/;
   /*
   trx = signed_trx.as<signed_transaction>();
   */
}