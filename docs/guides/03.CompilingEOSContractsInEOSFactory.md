# Compiling EOS Contracts in *EOSFactory*

The purpose of this tutorial is to demonstrate how *EOSFactory* and its Python CLI can be used to make compiling EOS contracts easy & intuitive.

## Prerequisites

This tutorial assumes that you have successfully installed *EOSFactory*. If it's not the case, please refer to [this guide](InstallingEOSFactory.md).

We also assume that you are familiar with the material covered in [Getting Started with EOS Contracts in *EOSFactory*](GettingStartedwithEOSContractsinEOSFactory.md).

Finally, we assume that you are familiar with the official [EOS Hello World tutorial](https://github.com/EOSIO/eos/wiki/Tutorial-Hello-World-Contract), as it presents the default way to compile and deploy smart-contracts in EOS. What we present here is an alternative.

## Set up the Workspace

In *Visual Studio Code*, switch to the bash console and type `python3` to run the Python CLI. The prompt should change to `>>>` signifying that it's ready for Python commands.

## Create a Contract Template

To create a new contract from a pre-defined template:

```
from eosf import *
```

```
contract = Template("hello")
```

To check the directory where the contract's files are located:

```
contract.path()
```

You can keep your contracts in any location you want. However, if it's a non-standard location (i.e. different from `eos/build/contracts` or `eosfactory/contracts`) then you'll need to provide the entire path to its folder. e.g.

```
contract = Contract("/mnt/d/Workspaces/EOS/eos/build/contracts/eosio.token")
```

## Add C++ code

Edit the `hello.cpp` file in *Visual Studio Code* and add the following content to it:

```
#include <eosiolib/eosio.hpp>
#include <eosiolib/print.hpp>
using namespace eosio;

class hello : public eosio::contract {
  public:
      using contract::contract;

      /// @abi action 
      void hi( account_name user ) {
         print( "Hello, ", name{user} );
      }
};

EOSIO_ABI( hello, (hi) )
```

## Compile the Contract

You can generate the web assembly code and ABI separately:

```
contract.compile_wast()
```

```
contract.compile_abi()
```

Or you can generate both at the same time:

```
contract.compile()
```

## Deploy the Contract

First, start the testnet and initialize the workspace:

```
import node, sess
```

```
node.reset()
```

```
sess.init()
```

Now we can deploy the compiled contract and keep reference to it for future use:

```
contract.deploy()
```

## Test the Contract

We can play with the contract giving it different arguments:

```
contract.push("hi", '{"user":"alice"}', sess.alice)
```

```
contract.push("hi", '{"user":"carol"}', sess.alice)
```

All the above variations should work, as the contract allows anyone to authorize it.

## Modify the code, re-compile & re-deploy

And now let's modify the `hi` method to make it authenticate the user we are dealing with:

```
void hi( account_name user ) {
	require_auth( user );
	print( "Hello, ", name{user} );
}
```

Re-compile the contract:

```
contract.compile()
```

Reset and re-initialize the testnet:

```
node.reset()
```

```
sess.init()
```

And finally, re-deploy the contract:

```
contract.deploy()
```

Now, if we attempt to mismatch the user and the authority, the contract will throw an error:

```
contract.push("hi", '{"user":"carol"}', sess.alice)
```

```
Error 3030001: missing required authority
Ensure that you have the related authority inside your transaction!;
Error Details:
missing authority of carol
```

But if we use the appropriate authority, there should no error:

```
contract.push("hi", '{"user":"carol"}', sess.carol)
```

